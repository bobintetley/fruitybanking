#!/usr/bin/env python

import accounts
import datetime
import time
import db
import locale

#locale.setlocale(locale.LC_ALL, 'en_US')

def number_format(num, places=2):
    return locale.format("%.*f", (places, num), True)

class Transaction:
    """
        Transaction DTO. It's quite different from the
        data structure (which uses source/dest/amount)
        to match the UI, which has accountid (which you're in
        now), otheraccountid (other side of the transaction) and
        whether this is a deposit or a withdrawal (and the balance
        to date).
        
        The data is transformed from this to the source/dest/amount
        structure in the database by the get/update routines.
    """
    id = 0
    date = datetime.date.today()
    description = ""
    reconciled = 0
    accountid = 0
    otheraccountid = 0
    otheraccountcode = ""
    deposit = 0
    withdrawal = 0
    balance = 0
    
def updateTransaction(transactionObj):
    """
        Updates a Transaction objects database record.
    """
    # Sort out which way round the accounts are
    if float(transactionObj.deposit) > 0:
        sourceaccount = transactionObj.otheraccountid
        destaccount = transactionObj.accountid
        amount = transactionObj.deposit
    else:
        sourceaccount = transactionObj.accountid
        destaccount = transactionObj.otheraccountid
        amount = transactionObj.withdrawal
    
    s = "UPDATE trx SET Date = %s, Description='%s', Amount=%s, SourceAccountID=%s, DestinationAccountID=%s, Reconciled=%s WHERE ID=%s" % ( str(toUnixDate(transactionObj.date)), transactionObj.description, amount, sourceaccount, destaccount, transactionObj.reconciled, transactionObj.id )
    db.executeQuery(s)
    
def createTransaction(transactionObj):
    """
        Creates a transaction record from a supplied 
	Transaction object (ID is ignored and regenerated on the object)
    """
    # Get the next ID for the table
    tid = int(db.getId("trx"))
    transactionObj.id = tid

    isreconciled = 0
    if str(transactionObj.reconciled) == "on":
        isreconciled = 1
    
    # Sort out which way round the accounts are
    if float(transactionObj.deposit) > 0:
        sourceaccount = transactionObj.otheraccountid
        destaccount = transactionObj.accountid
        amount = transactionObj.deposit
    else:
        sourceaccount = transactionObj.accountid
        destaccount = transactionObj.otheraccountid
        amount = transactionObj.withdrawal
        
    s = "INSERT INTO trx (ID, Date, Description, Reconciled, Deleted, Amount, SourceAccountID, DestinationAccountID) VALUES ( " + str(tid) + ", '" + str(int(toUnixDate(transactionObj.date))) + "', " + "'" + transactionObj.description + "', " + str(isreconciled) + ", 0, " + amount + ", " + sourceaccount + ", " + destaccount + ")"
    db.executeQuery(s)
    
def getTransactions(accountid, datefrom, dateto):
    """
        Return all the Transaction objects where accountid is the
        source or dest account. The Transaction amount is converted
        to a deposit or withdrawal amount depending on whether
        the account is the source account or not (if it's the source,
        then it's a withdrawal, dest is a deposit).
        
        Balances are also generated by this routine on the returned
        data as each DTO is created/populated.

    datefrom and dateto are unix dates specifying the transactions
    to show.
	The num parameter specifies how many results we are actually
	interested (most recent). This is used to select a date
	cutoff. We calculate the balance to this date using the
	database (which is fast) and restrict rows to everything
	after this date so we don't waste time marshalling data into
	objects we aren't going to use. This is necessary since a few
	months worths of data can get large.
    """
    
    # The list to send back
    l = []
    
    # Retrieve all the relevant transaction records
    d = db.runQuery("SELECT ID, Date, Description, Reconciled, Amount, SourceAccountID, DestinationAccountID FROM trx WHERE Deleted = 0 AND Date >= %s AND Date <= %s AND (SourceAccountID=%s OR DestinationAccountID=%s) ORDER BY Date" % (datefrom, dateto, accountid, accountid))

    # Start the cumulative balance upto (but not including) the cut off date
    balance = accounts.getAccountBalanceToDate(accountid, datefrom)

    # Loop through the rows
    for row in range(len(d)):
        
        t = Transaction()
        t.id = d[row][0]
        t.accountid = accountid
        t.date = toPythonDate(d[row][1])
        t.description = d[row][2]
        t.reconciled = d[row][3]
        
        # If the account is the source, then it must be a
        # withdrawal and the dest account is the "other" account
        if (int(d[row][5]) == int(accountid)):
            t.withdrawal = d[row][4]
            t.deposit = 0
            t.otheraccountid = d[row][6]
            t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
            balance = balance - t.withdrawal
        else:
            # It's a deposit and the source account is the "other" account
            t.deposit = d[row][4]
            t.withdrawal = 0
            t.otheraccountid = d[row][5]
            t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
            balance = balance + t.deposit
        
        t.balance = balance
        
        # Add this transaction to the list
        l.append(t)
    
    return l

def getReconciledAsHTML(selected = 0):
    """
        Returns HTML options representing whether a transaction is
        reconciled.
    """
    sel = ""
    s = ""
    if selected == 0: sel = "selected "
    s = s + "<option %svalue='%s'>%s</option>" % ( sel, "0", "No" )
    sel = ""
    if selected == 1: sel = "selected "
    s = s + "<option %svalue='%s'>%s</option>" % ( sel, "1", "Yes" )
    return s

def markAllTransactionsReconciled(accountid):
    """
       Marks all transactions upto today as reconciled
       for the given account id.
    """
    db.executeQuery("UPDATE trx SET Reconciled = 1 WHERE Date <= %s AND (SourceAccountID = %s OR DestinationAccountID = %s)" % ( toUnixDate(datetime.date.today()), accountid, accountid ))

def markTransactionReconciled(transactionid):
    """
        Marks a given transaction as reconciled against
    a bank statement.
    """
    db.executeQuery("UPDATE trx SET reconciled = 1 WHERE ID = %s" % transactionid)
    
def getTransactionById(transactionid, accountid):
    """
        Return the Transaction object for a given id
        requires the accountid as well as the transactionid
        so that the transaction object can have the correct
        other account.
    """

    d = db.runQuery("SELECT ID, Date, Description, Reconciled, Amount, SourceAccountID, DestinationAccountID FROM trx WHERE ID=%s" % transactionid)    
    t = Transaction()
    t.id = d[0][0]
    t.accountid = accountid
    t.date = toPythonDate(d[0][1])
    t.description = d[0][2]
    t.reconciled = d[0][3]
    
    # If the account is the source, then it must be a
    # withdrawal and the dest account is the "other" account
    if (int(d[0][5]) == int(accountid)):
        t.withdrawal = d[0][4]
        t.deposit = 0
        t.otheraccountid = d[0][6]
        t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
    else:
        # It's a deposit and the source account is the "other" account
        t.deposit = d[0][4]
        t.withdrawal = 0
        t.otheraccountid = d[0][5]
        t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
        
    return t
    
def deleteTransaction(transactionid):
    """
        Marks a Transaction as deleted
    """
    db.executeQuery("UPDATE trx SET Deleted=1 WHERE ID = %s" % transactionid)
    
def getToday():
    """
        Return today's date, formatted for the user.
    """
    return pythonToDisplayDate(datetime.date.today())

def toUnixDate(d):
    """
        Converts a Python date to a UNIX date
    """
    return time.mktime(d.timetuple())

def toPythonDate(d):
    """
        Converts a UNIX date to a Python date
    """
    return datetime.date.fromtimestamp(float(d))

def displayToPythonDate(d):
    """
        Converts a display date to a Python date
    """
    datebits = d.split("/")
    return datetime.date(int(datebits[2]), int(datebits[1]), int(datebits[0]))

def pythonToDisplayDate(d):
    """
        Converts a Python date to a display date
    """
    return "%s/%s/%s" % (d.day, d.month, d.year)

