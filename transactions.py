
import accounts
import datetime
import time
import db

class Transaction:
    """
        Transaction DTO. It's quite different from the
        data structure (which uses source/dest/amount)
        to match the UI, which has accountid (which you're in
        now), otheraccountid (other side of the transaction) and
        whether this is a deposit or a withdrawal (and the balance
        to date).
        
        The data is transformed from this to the source/dest/amount
        structure in the database by the get/update routines.
    """
    id = 0
    date = datetime.date.today()
    description = ""
    reconciled = 0
    vat = 0
    accountid = 0
    otheraccountid = 0
    otheraccountcode = ""
    deposit = 0
    withdrawal = 0
    balance = 0
    
def updateTransaction(transactionObj):
    """
        Updates a Transaction objects database record.
    """
    # Sort out which way round the accounts are
    if float(transactionObj.deposit) > 0:
        sourceaccount = transactionObj.otheraccountid
        destaccount = transactionObj.accountid
        amount = transactionObj.deposit
    else:
        sourceaccount = transactionObj.accountid
        destaccount = transactionObj.otheraccountid
        amount = transactionObj.withdrawal
   
    db.db.update("trx", date=toUnixDate(transactionObj.date), description=transactionObj.description, amount=amount, sourceaccountid=sourceaccount, destinationaccountid=destaccount, reconciled=transactionObj.reconciled, vat=transactionObj.vat, where="id=%d" % int(transactionObj.id))
    
def createTransaction(transactionObj):
    """
        Creates a transaction record from a supplied 
        Transaction object (id is ignored and regenerated on the object)
    """
    # Get the next id for the table
    tid = int(db.getId("trx"))
    transactionObj.id = tid

    isreconciled = 0
    if str(transactionObj.reconciled) == "on":
        isreconciled = 1

    isvat = 0
    if str(transactionObj.vat) == "on":
        isvat = 1
    
    # Sort out which way round the accounts are
    if float(transactionObj.deposit) > 0:
        sourceaccount = transactionObj.otheraccountid
        destaccount = transactionObj.accountid
        amount = transactionObj.deposit
    else:
        sourceaccount = transactionObj.accountid
        destaccount = transactionObj.otheraccountid
        amount = transactionObj.withdrawal
        
    db.db.insert("trx", id=tid, date=toUnixDate(transactionObj.date), description=transactionObj.description, amount=amount, sourceaccountid=sourceaccount, destinationaccountid=destaccount, reconciled=isreconciled, vat=isvat, deleted=0)
    return tid
    
def getTransactions(accountid, datefrom, dateto):
    """
        Return all the Transaction objects where accountid is the
        source or dest account. The Transaction amount is converted
        to a deposit or withdrawal amount depending on whether
        the account is the source account or not (if it's the source,
        then it's a withdrawal, dest is a deposit).
        
        Balances are also generated by this routine on the returned
        data as each DTO is created/populated.

        datefrom and dateto are unix dates specifying the transactions
        to show.

        The num parameter specifies how many results we are actually
        interested (most recent). This is used to select a date
        cutoff. We calculate the balance to this date using the
        database (which is fast) and restrict rows to everything
        after this date so we don't waste time marshalling data into
        objects we aren't going to use. This is necessary since a few
        months worths of data can get large.
    """
    
    # The list to send back
    l = []
    
    # Retrieve all the relevant transaction records
    d = db.runQuery("SELECT id, date, description, reconciled, vat, amount, sourceaccountid, destinationaccountid FROM trx WHERE deleted = 0 AND date >= %s AND date <= %s AND (sourceaccountid=%s OR destinationaccountid=%s) ORDER BY date" % (datefrom, dateto, accountid, accountid))

    # Start the cumulative balance upto (but not including) the cut off date
    balance = accounts.getAccountBalanceToDate(accountid, datefrom)

    # Loop through the rows
    for row in d:
        
        t = Transaction()
        t.id = row.id
        t.accountid = accountid
        t.date = toPythonDate(row.date)
        t.description = row.description
        t.reconciled = row.reconciled
        t.vat = row.vat
        
        # If the account is the source, then it must be a
        # withdrawal and the dest account is the "other" account
        if (row.sourceaccountid == int(accountid)):
            t.withdrawal = row.amount
            t.deposit = 0
            t.otheraccountid = row.destinationaccountid
            t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
            balance = balance - t.withdrawal
        else:
            # It's a deposit and the source account is the "other" account
            t.deposit = row.amount
            t.withdrawal = 0
            t.otheraccountid = row.sourceaccountid
            t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
            balance = balance + t.deposit
        
        t.balance = balance
        
        # Add this transaction to the list
        l.append(t)
    
    return l

def getFlagAsHTML(selected = 0):
    """
        Returns HTML options representing whether a flag is selected (1).
    """
    sel = ""
    s = ""
    if selected == 0: sel = "selected=\"selected\" "
    s = s + "<option %svalue='%s'>%s</option>" % ( sel, "0", "No" )
    sel = ""
    if selected == 1: sel = "selected=\"selected\" "
    s = s + "<option %svalue='%s'>%s</option>" % ( sel, "1", "Yes" )
    return s

def markAllTransactionsReconciled(accountid):
    """
       Marks all transactions upto today as reconciled
       for the given account id.
    """
    db.db.update("trx", reconciled=1, where="Date <= $ud AND (SourceAccountID = $sa OR DestinationAccountID = $sa)", vars={ "ud": toUnixDate(datetime.date.today()), "sa": accountid} )

def markTransactionReconciled(transactionid):
    """
        Marks a given transaction as reconciled against
    a bank statement.
    """
    db.db.update("trx", reconciled=1, where="id=%d" % int(transactionid))

def markTransactionVAT(transactionid):
    """
        Marks a given transaction as vattable
    """
    db.db.update("trx", vat=1, where="id=%d" % int(transactionid))
    
def getTransactionById(transactionid, accountid):
    """
        Return the Transaction object for a given id
        requires the accountid as well as the transactionid
        so that the transaction object can have the correct
        other account.
    """

    d = db.runQuery("SELECT id, date, description, reconciled, vat, amount, sourceaccountid, destinationaccountid FROM trx WHERE id=%s" % transactionid)
    t = Transaction()
    t.id = d[0].id
    t.accountid = accountid
    t.date = toPythonDate(d[0].date)
    t.description = d[0].description
    t.reconciled = d[0].reconciled
    t.vat = d[0].vat
    
    # If the account is the source, then it must be a
    # withdrawal and the dest account is the "other" account
    if (int(d[0].sourceaccountid) == int(accountid)):
        t.withdrawal = d[0].amount
        t.deposit = 0
        t.otheraccountid = d[0].destinationaccountid
        t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
    else:
        # It's a deposit and the source account is the "other" account
        t.deposit = d[0].amount
        t.withdrawal = 0
        t.otheraccountid = d[0].sourceaccountid
        t.otheraccountcode = accounts.getAccountById(t.otheraccountid).code
        
    return t
    
def deleteTransaction(transactionid):
    """
        Marks a Transaction as deleted
    """
    db.db.update("trx", deleted=1, where="id=%d" % int(transactionid))
    
def getToday():
    """
        Return today's date, formatted for the user.
    """
    return pythonToDisplayDate(datetime.date.today())

def toUnixDate(d):
    """
        Converts a Python date to a UNIX date
    """
    return time.mktime(d.timetuple())

def toPythonDate(d):
    """
        Converts a UNIX date to a Python date
    """
    return datetime.date.fromtimestamp(float(d))

def displayToPythonDate(d):
    """
        Converts a display date to a Python date
    """
    datebits = d.split("/")
    return datetime.date(int(datebits[2]), int(datebits[1]), int(datebits[0]))

def pythonToDisplayDate(d):
    """
        Converts a Python date to a display date
    """
    return "%s/%s/%s" % (d.day, d.month, d.year)

